import{_ as n,o as t,c as a,k as e,a as l}from"./chunks/framework.S8W019Nk.js";const V=JSON.parse('{"title":"模块热替换 - HMR(Hot Module Replacement)","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/concepts/webpack/hmr.md","filePath":"frontend/concepts/webpack/hmr.md"}'),o={name:"frontend/concepts/webpack/hmr.md"},s=e("h1",{id:"模块热替换-hmr-hot-module-replacement",tabindex:"-1"},[l("模块热替换 - HMR(Hot Module Replacement) "),e("a",{class:"header-anchor",href:"#模块热替换-hmr-hot-module-replacement","aria-label":'Permalink to "模块热替换 - HMR(Hot Module Replacement)"'},"​")],-1),c=e("p",null,[e("span",{hl:""},"HMR"),l("会在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面。其主要通过一下几种方式，来显著加快开发速度：")],-1),i=e("ul",null,[e("li",null,"保留在完全重新加载页面期间丢失的应用程序状态"),e("li",null,"只更新变更内容，以节省宝贵的开发时间"),e("li",null,"在源代码中CSS/JS产生修改时，会立即在浏览器中进行更新，这几乎相当于在浏览器devtools直接修改样式")],-1),h=e("h2",{id:"应用",tabindex:"-1"},[l("应用 "),e("a",{class:"header-anchor",href:"#应用","aria-label":'Permalink to "应用"'},"​")],-1),r=e("p",null,"通过以下步骤，可以让应用程序中的模块被置换：",-1),d=e("ol",null,[e("li",null,[e("p",null,[l("应用程序要求"),e("span",{hl:""},"HMR runtime"),l("检查更新")])]),e("li",null,[e("p",null,"HMR runtime异步下载需更新的模块，然后通知应用程序")]),e("li",null,[e("p",null,"应用程序要求HMR runtime更新模块")]),e("li",null,[e("p",null,"HMR runtime同步更新模块")])],-1),u=e("h2",{id:"compiler",tabindex:"-1"},[l("Compiler "),e("a",{class:"header-anchor",href:"#compiler","aria-label":'Permalink to "Compiler"'},"​")],-1),p=e("p",null,[l("除了一些普通资源，compiler需要发出"),e("code",null,"update"),l("，将旧版本更新到新版本。"),e("code",null,"update"),l("由两部分组成：")],-1),_=e("ul",null,[e("li",null,[l("更新后的"),e("span",{hl:""},"manifest")]),e("li",null,"一个或多个更新后的chunk")],-1),m=e("p",null,"manifest包括新的compilation hash和所有更新后的chunk列表。每个chunk都包含全部更新模块的最新代码（或一个标记此模块需被移除的flag）。",-1),k=e("p",null,"compiler会确保在这些构建中的模块id和chunk id保持一致。通常将这些id存储在内存中，也有可能将它们存在一个JSON文件中。",-1),f=e("h2",{id:"模块",tabindex:"-1"},[l("模块 "),e("a",{class:"header-anchor",href:"#模块","aria-label":'Permalink to "模块"'},"​")],-1),R=e("p",null,"在模块中可以通过实现HMR接口，描述当模块更新后发生了什么。",-1),b=e("p",null,[l("大多数情况下，不需要在每个模块中强行写入HMR代码。如果一个模块没有HMR处理函数，更新就会"),e("span",{hl:""},"冒泡"),l("。这意味着某个单独处理函数能够更新整个模块树。如果在模块树的一个单独模块被更新，那么整组依赖模块都会被重新加载。")],-1),H=e("h2",{id:"runtime",tabindex:"-1"},[l("Runtime "),e("a",{class:"header-anchor",href:"#runtime","aria-label":'Permalink to "Runtime"'},"​")],-1),M=e("p",null,[l("模块系统运行时（module system runtime）会通过额外的代码跟踪模块"),e("span",{hl:""},"parents"),l("和"),e("span",{hl:""},"children"),l("的关系。在管理方面，runtime支持两个方法"),e("code",null,"check"),l("和"),e("code",null,"apply"),l("。")],-1),x=e("p",null,[e("code",null,"check"),l("方法，会发送一个HTTP请求来更新manifest。如果请求失败，说明没有可用更新。如果请求成功，会将已更新的chunk列表与当前已加载的chunk列表进行比较。每个已加载的chunk都会下载相应的已更新的chunk。当所有chunk都下载完成后，runtime将切换到"),e("span",{hl:""},"ready"),l("状态。")],-1),P=e("p",null,[e("code",null,"apply"),l("方法，会将所有已更新的模块标记为无效。每个无效的模块都需有一个"),e("span",{hl:""},"update handler"),l("，或者在其父模块中有update handler。否则会进行无效标记冒泡，并且父级也会被标记为无效。继续每个冒泡，直到到达最近的含有update handler的模块，随后结束冒泡。若冒泡一直未停止，则最终会到达应用程序入口起点。")],-1),g=e("p",null,[l("最后，所有无效的模块都会通过"),e("span",{hl:""},"dispose handler"),l("处理和卸载。然后更新当前hash，并且调用所有"),e("span",{hl:""},"accept handler"),l("。runtime切换为"),e("span",{hl:""},"idle"),l("状态，如此往复。")],-1),S=e("p",null,[e("span",{hlbg:""},"参考链接：")],-1),w=e("ul",null,[e("li",null,[e("a",{href:"https://webpack.js.org/concepts/hot-module-replacement/",target:"_blank",rel:"noreferrer"},"Hot Module Replacement")])],-1),y=[s,c,i,h,r,d,u,p,_,m,k,f,R,b,H,M,x,P,g,S,w];function N($,v,B,C,J,T){return t(),a("div",null,y)}const j=n(o,[["render",N]]);export{V as __pageData,j as default};
