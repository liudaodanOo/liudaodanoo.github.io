import{_ as n,o as h,c as l,k as s,a as i,R as a}from"./chunks/framework.S8W019Nk.js";const t="/assets/eventflow.vsasS_Kb.svg",X=JSON.parse('{"title":"关于原生JS的概念","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/concepts/javascript.md","filePath":"frontend/concepts/javascript.md"}'),k={name:"frontend/concepts/javascript.md"},p=s("h1",{id:"关于原生js的概念",tabindex:"-1"},[i("关于原生JS的概念 "),s("a",{class:"header-anchor",href:"#关于原生js的概念","aria-label":'Permalink to "关于原生JS的概念"'},"​")],-1),e=s("h2",{id:"什么是事件流",tabindex:"-1"},[i("什么是事件流？ "),s("a",{class:"header-anchor",href:"#什么是事件流","aria-label":'Permalink to "什么是事件流？"'},"​")],-1),r=s("p",null,[s("strong",null,"事件流"),i("描述的是页面中事件传递的过程。分为三个阶段。")],-1),E=s("ol",null,[s("li",null,"捕获阶段（Capture Phase）：事件以从Window到目标父对象的顺序，在事件对象的祖先中传播"),s("li",null,[i("触发阶段（Target Phase）：事件对象到达事件对象的目标。如果"),s("span",{hl:""},"Event.bubbles = false"),i("，对事件对象的处理在这个阶段后就会结束")]),s("li",null,"冒泡阶段（Bubble Phase）：事件以相反的顺序在事件对象的祖先中传播，从目标父对象到Window")],-1),d=a("",6),g=s("p",null,[s("span",{hlbg:""},"参考链接：")],-1),F=a("",14),y=s("p",null,[s("span",{hlbg:""},"参考链接：")],-1),o=a("",7),c=s("p",null,[s("span",{hlbg:""},"参考链接：")],-1),C=a("",10),D=s("p",null,[s("span",{hlbg:""},"参考链接：")],-1),B=s("ul",null,[s("li",null,[s("a",{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures",target:"_blank",rel:"noreferrer"},"MDN #closure")])],-1),_=s("h2",{id:"babel如何编译let和const",tabindex:"-1"},[i("Babel如何编译let和const？ "),s("a",{class:"header-anchor",href:"#babel如何编译let和const","aria-label":'Permalink to "Babel如何编译let和const？"'},"​")],-1),u=s("p",null,[i("Babel会将let和const都编译成"),s("span",{hl:""},"var")],-1),A=a("",6),b=s("p",null,[i("Babel会创建一个"),s("span",{hl:""},"_readOnlyError"),i("方法，赋值操作变成了调用_readOnlyError方法。")],-1),v=a("",4),f=s("p",null,[i("Babel编译后会创建一个"),s("span",{hl:""},"_loop"),i("函数，利用"),s("span",{hl:""},"闭包"),i("保存索引的值。")],-1),m=a("",5),T=s("p",null,[s("span",{hl:""},"普通函数"),i("中this的值由该函数的调用方式决定，在运行时绑定。")],-1),P=s("ul",null,[s("li",null,[s("p",null,"作为单独的函数调用，this通常指向全局对象（非严格模式）或undefined（严格模式）")]),s("li",null,[s("p",null,"作为对象的函数调用时，this指向这个对象")])],-1),j=s("p",null,[s("span",{hl:""},"箭头函数"),i("中this的值会在定义时从其父作用域的this继承。所以箭头函数无法通过Function.prototype.call、Function.prototype.apply、Function.prototype.bind修改this。")],-1),S=s("p",null,[s("span",{hl:""},"构造函数"),i("中this会绑定到构造的新对象，除非构造函数返回其他非原始值。")],-1),q=s("p",null,[s("span",{hl:""},"全局上下文"),i("中this的值会根据运行时的环境确定（调用者）。在脚本的顶层，无论是否严格模式，this都指向全局对象。若脚本被当作模块加载，则this的值为undefined。")],-1),w=a("",5),N=s("p",null,[i("它们的优先级由高到低分别为："),s("span",{hl:""},"new > call、apply、bind > 隐式绑定"),i("。")],-1),V=a("",5),I=s("p",null,[s("span",{hlbg:""},"参考链接：")],-1),x=a("",4),J=s("p",null,[s("span",{hlbg:""},"参考链接：")],-1),R=a("",19),O=s("p",null,[s("span",{hlbg:""},"参考链接：")],-1),z=s("ul",null,[s("li",null,[s("a",{href:"https://juejin.cn/post/7111902909796712455",target:"_blank",rel:"noreferrer"},"Javascript高级篇之函数柯里化")]),s("li",null,[s("a",{href:"https://docs.pingcode.com/ask/89142.html",target:"_blank",rel:"noreferrer"},"JavaScript中的函数柯里化")]),s("li",null,[s("a",{href:"https://cloud.tencent.com/developer/article/1794267",target:"_blank",rel:"noreferrer"},"一文讲懂什么是函数柯里化，柯里化的目的及其代码实现")])],-1),U=[p,e,r,E,d,g,F,y,o,c,C,D,B,_,u,A,b,v,f,m,T,P,j,S,q,w,N,V,I,x,J,R,O,z];function M(W,$,L,G,K,H){return h(),l("div",null,U)}const Y=n(k,[["render",M]]);export{X as __pageData,Y as default};
